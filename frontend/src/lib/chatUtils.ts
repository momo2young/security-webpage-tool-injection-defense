
export interface ContentBlock {
  type: 'markdown' | 'code' | 'log';
  content: string;
  lang?: string;
  title?: string;
}

// Helper to normalize Python code indentation
export function normalizePythonCode(code: string): string {
  const lines = code.split('\n');
  if (lines.length === 0) return code;
  
  // Find minimum indentation (ignoring empty lines)
  let minIndent = Infinity;
  for (const line of lines) {
    if (line.trim().length > 0) {
      const leadingSpaces = line.match(/^[ ]*/)?.[0].length || 0;
      minIndent = Math.min(minIndent, leadingSpaces);
    }
  }
  
  // Remove the minimum indentation from all lines
  if (minIndent > 0 && minIndent !== Infinity) {
    return lines.map(line => 
      line.trim().length > 0 ? line.slice(minIndent) : line
    ).join('\n');
  }
  
  return code;
}

// Helper to generate stable key for a block based on its position and type
// During streaming, blocks grow but don't change position, so index is stable
export function generateBlockKey(block: ContentBlock, index: number, messageIdx: number): string {
  // Use message index + block index + type for a stable key that doesn't change as content grows
  return `msg-${messageIdx}-block-${index}-${block.type}`;
}

// Helper to split assistant content into markdown + code + log blocks
export function splitAssistantContent(content: string): ContentBlock[] {
  const blocks: ContentBlock[] = [];
  
  // Regex to find <details> blocks (logs)
  // Matches <details><summary>TITLE</summary>...<pre><code class="language-text">CONTENT</code></pre>...</details>
  // We use a simpler regex that assumes the structure generated by streaming.ts
  const logRegex = /<details><summary>(.*?)<\/summary>\s*<pre><code class="language-text">([\s\S]*?)<\/code><\/pre>\s*<\/details>/g;
  
  let lastIndex = 0;
  let match;

  // First pass: split by log blocks
  const logSplits: { type: 'markdown' | 'log'; content: string; title?: string }[] = [];
  
  while ((match = logRegex.exec(content)) !== null) {
    const before = content.slice(lastIndex, match.index);
    if (before) {
      logSplits.push({ type: 'markdown', content: before });
    }
    
    // Decode HTML entities in content for display
    const rawContent = match[2]
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#039;/g, "'");
      
    logSplits.push({ 
      type: 'log', 
      title: match[1], 
      content: rawContent 
    });
    
    lastIndex = logRegex.lastIndex;
  }
  
  const remaining = content.slice(lastIndex);
  if (remaining) {
    logSplits.push({ type: 'markdown', content: remaining });
  }

  // Second pass: process markdown blocks for code fences
  for (const split of logSplits) {
    if (split.type === 'log') {
      blocks.push(split as ContentBlock);
      continue;
    }

    // Process markdown for code blocks (existing logic)
    let i = 0;
    const subContent = split.content;
    const len = subContent.length;
    let currentMarkdown = '';
    
    while (i < len) {
      const fenceStart = subContent.indexOf('```', i);
      if (fenceStart === -1) {
        currentMarkdown += subContent.slice(i);
        break;
      }
      
      currentMarkdown += subContent.slice(i, fenceStart);
      const langLineEnd = subContent.indexOf('\n', fenceStart + 3);
      
      if (langLineEnd === -1) {
        currentMarkdown += subContent.slice(fenceStart);
        i = len;
        break;
      }
      
      const langToken = subContent.slice(fenceStart + 3, langLineEnd).trim();
      const cleanLang = langToken.replace(/[^a-zA-Z0-9_-]/g, '').toLowerCase();
      const validLanguages = ['python', 'javascript', 'typescript', 'java', 'cpp', 'c', 'go', 'rust', 'sql', 'html', 'css', 'json', 'yaml', 'xml', 'bash', 'shell', 'powershell', 'php', 'ruby', 'swift', 'kotlin', 'dart', 'r', 'matlab', 'scala', 'perl', 'lua', 'haskell', 'clojure', 'elixir', 'erlang', 'fsharp', 'ocaml', 'pascal', 'fortran', 'cobol', 'assembly', 'asm', 'text', 'plain'];
      const lang = validLanguages.includes(cleanLang) ? cleanLang : 'text';
      
      const closingFence = subContent.indexOf('\n```', langLineEnd + 1);
      
      if (closingFence === -1) {
        if (currentMarkdown) {
          blocks.push({ type: 'markdown', content: currentMarkdown });
          currentMarkdown = '';
        }
        let codeBody = subContent.slice(langLineEnd + 1);
        if (lang === 'python') codeBody = normalizePythonCode(codeBody);
        blocks.push({ type: 'code', content: codeBody, lang });
        i = len;
        break;
      } else {
        if (currentMarkdown) {
          blocks.push({ type: 'markdown', content: currentMarkdown });
          currentMarkdown = '';
        }
        let codeBody = subContent.slice(langLineEnd + 1, closingFence);
        if (lang === 'python') codeBody = normalizePythonCode(codeBody);
        blocks.push({ type: 'code', content: codeBody, lang });
        i = closingFence + 4;
      }
    }
    if (currentMarkdown) {
      blocks.push({ type: 'markdown', content: currentMarkdown });
    }
  }
  
  return blocks.filter(b => b.content !== '');
}
